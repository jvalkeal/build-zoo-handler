# Dispatch Handler

Feature to centrally handle repository dispatches consist of a two parts,
firstly to have a workflow which acts as a central dispatch controller
listenting dispatch messages, and secondly able to send dispatch message into
a controller. Together these two features can orchestrate event based dispatch
flow starting from one workflow originating from an GitHub UI as a workflow
dispatch and ending when there is no more work to do.

Generic idea of this feature is to handle a _Release Train_ where multiple
Github projects depends on each others so that one needs to be build and
released before dependant project can build build and released. As a simple
example you have three _Spring Boot_ projects, `project1`,
`project2` and `project3` where dependency tree simply is
`project1` -> `project2` -> `project3`.

This feature splits into two parts, firstly it can send a repository
dispatch messages, and secondly centrally control these dispatch messages
to make decision what to do next in a flow.

## Example with Two Repos

We'd have a three repositories under user `owner` named `repo1`, `repo2`
and `repo3`. Firstly we can create a workflow on a repo `repo2` which
gets fired with _repository_dispatch_ on event type _build-zoo-handler-example_.
With a configuration we need to define _token_ for authentication, repository
with _owner_ and _repo_ and _event type_. Last a custom json where it's possible
to define various parameters like _event_ itself. These are then processed
in a controller workflow.

[source,yaml]
----
name: Repo2 Work

on:
  repository_dispatch:
    types: [build-zoo-handler-example]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:

    - name: Do Something
      run: echo hi

    # zoo notify success
    - name: Notify Build Success Zoo Handler Controller
      uses: jvalkeal/build-zoo-handler@main
      with:
        dispatch-handler-token: ${{ secrets.REPO_ACCESS_TOKEN }}
        dispatch-handler-owner: owner
        dispatch-handler-repo: repo1
        dispatch-handler-event-type: build-zoo-handler-example
        dispatch-handler-client-payload-data: >
          {
            "event": "work-succeed"
          }

    # zoo notify failed
    - name: Notify Build Failure Zoo Handler Controller
      if: ${{ failure() }}
      uses: jvalkeal/build-zoo-handler@main
      with:
        dispatch-handler-token: ${{ secrets.REPO_ACCESS_TOKEN }}
        dispatch-handler-owner: owner
        dispatch-handler-repo: repo1
        dispatch-handler-event-type: build-zoo-handler-example
        dispatch-handler-client-payload-data: >
          {
            "event": "work-failed",
            "message": "repo2 failed"
          }
----

Same workflow for repo `repo3`.

[source,yaml]
----
name: Repo3 Work

on:
  repository_dispatch:
    types: [build-zoo-handler-example]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:

    - name: Do Something
      run: echo hi

    # zoo notify success
    - name: Notify Build Success Zoo Handler Controller
      uses: jvalkeal/build-zoo-handler@main
      with:
        dispatch-handler-token: ${{ secrets.REPO_ACCESS_TOKEN }}
        dispatch-handler-owner: owner
        dispatch-handler-repo: repo1
        dispatch-handler-event-type: build-zoo-handler-example
        dispatch-handler-client-payload-data: >
          {
            "event": "work-succeed"
          }

    # zoo notify failed
    - name: Notify Build Failure Zoo Handler Controller
      if: ${{ failure() }}
      uses: jvalkeal/build-zoo-handler@main
      with:
        dispatch-handler-token: ${{ secrets.REPO_ACCESS_TOKEN }}
        dispatch-handler-owner: owner
        dispatch-handler-repo: repo1
        dispatch-handler-event-type: build-zoo-handler-example
        dispatch-handler-client-payload-data: >
          {
            "event": "work-failed",
            "message": "repo3 failed"
          }
----

Interesting and a real dispatch orchestration happens within a controller workflow.
With a _handler config_ it's possible to define various cases where next dispatch
should be sent by checking source repository and event.

[source,yaml]
----
name: Zoo Controller

on:
  workflow_dispatch:
  repository_dispatch:
    types: [build-zoo-handler-control-example]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:

    - name: Handle Zoo Control
      uses: jvalkeal/build-zoo-handler@main
      with:
        dispatch-handler-token: ${{ secrets.REPO_ACCESS_TOKEN }}
        dispatch-handler-config: >
          [
            {
              "if": "initial == true",
              "action": "repository_dispatch",
              "repository_dispatch": {
                "owner": "owner",
                "repo": "repo2",
                "event_type": "build-zoo-handler-example"
              }
            },
            {
              "if": "data.event == 'work-succeed' && data.repo == 'repo2' && data.owner == 'owner'",
              "action": "repository_dispatch",
              "repository_dispatch": {
                "owner": "owner",
                "repo": "repo1",
                "event_type": "build-zoo-handler-example"
              }
            },
            {
              "if": "data.event == 'work-failed'",
              "action": "fail",
              "fail": {
                "message": "hi, something went wrong"
              }
            }
          ]
----

As this controller workflow can also get dispatched manually from GitHub UI due
to presence of _workflow dispatch_ few things happen after that.

* With `if` expression we choose targer dispatch when initial in a context is true.
* _repository dispatch_ gets send to `repo2`.
* `repo2` calls home back to controller.
* Now a controller can choose a case where `repo2` notified successful run
  via `work-succeed` event.
* Then controller goes ahead and dispatches into `repo3`.
* `repo3` calls home and there is no more work to do.
* Dispatch flow stops there.
* In case remote workflow fails, fallback step runs and notifies controller
  about its failure and then controller workflow fails as well together
  with a `message` payload field passed in from a remote workflow.
